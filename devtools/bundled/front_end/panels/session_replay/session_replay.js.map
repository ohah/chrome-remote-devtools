{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/session_replay/SessionReplayPanel.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as UI from '../../ui/legacy/legacy.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as ProtocolClient from '../../core/protocol_client/protocol_client.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport { Replayer, type ReplayerClass, cssStyles } from '../../third_party/rrweb-replay/rrweb-replay.js';\n\nlet sessionReplayPanelInstance: SessionReplayPanel;\n\nexport class SessionReplayPanel extends UI.Panel.Panel {\n  #rrwebEvents: unknown[] = [];\n  #container: HTMLElement|null = null;\n  #target: SDK.Target.Target|null = null;\n  #observer: ProtocolClient.CDPConnection.CDPConnectionObserver|null = null;\n  #replayer: InstanceType<ReplayerClass>|null = null; // Replayer instance / Replayer 인스턴스\n  #rrwebLoaded = false; // Flag to track if rrweb is loaded / rrweb 로드 여부 플래그\n  #controlsContainer: HTMLElement|null = null; // Controls container / 컨트롤 컨테이너 (for future use / 향후 사용)\n  #playPauseButton: HTMLElement|null = null; // Play/pause button / 재생/일시정지 버튼\n  #progressBar: HTMLElement|null = null; // Progress bar / 진행 바\n  #progressFill: HTMLElement|null = null; // Progress fill / 진행 채우기\n  #timeDisplay: HTMLElement|null = null; // Time display / 시간 표시\n  #isPlaying = false; // Playing state / 재생 상태\n  #currentTime = 0; // Current time in ms / 현재 시간 (ms)\n  #totalTime = 0; // Total time in ms / 총 시간 (ms)\n  #updateInterval: number|null = null; // Update interval ID / 업데이트 간격 ID\n\n  constructor() {\n    super('session-replay');\n    this.render();\n  }\n\n  override wasShown(): void {\n    super.wasShown();\n\n    // Notify parent/opener window that SessionReplay panel is ready / 부모/opener 창에 SessionReplay 패널이 준비되었음을 알림\n    // Works for both iframe mode and WebSocket mode / iframe 모드와 웹소켓 모드 모두에서 동작\n    if (window !== window.top) {\n      // Iframe mode: send to parent / Iframe 모드: parent에 전송\n      window.parent.postMessage({ type: 'SESSION_REPLAY_READY' }, '*');\n    } else if (window.opener) {\n      // Popup/WebSocket mode: send to opener / Popup/웹소켓 모드: opener에 전송\n      window.opener.postMessage({ type: 'SESSION_REPLAY_READY' }, '*');\n    }\n\n    // Reset current time when panel is shown / 패널이 표시될 때 현재 시간 리셋\n    this.#currentTime = 0;\n\n    // Update container height when panel is shown / 패널이 표시될 때 컨테이너 높이 업데이트\n    this.updateContainerHeight();\n\n    // Update progress to reflect reset time / 리셋된 시간을 반영하여 진행 상태 업데이트\n    this.updateProgress();\n\n    // Setup CDP listener when panel is shown / 패널이 표시될 때 CDP 리스너 설정\n    this.setupCDPListener();\n\n    // Also try to setup listener after a short delay in case target becomes available / 타겟이 나중에 사용 가능해질 수 있으므로 짧은 지연 후에도 시도\n    setTimeout(() => {\n      if (!this.#target) {\n        this.setupCDPListener();\n      }\n      // Update height again after delay to ensure correct calculation / 지연 후 높이를 다시 업데이트하여 정확한 계산 보장\n      this.updateContainerHeight();\n    }, 1000);\n  }\n\n  private setupCDPListener(): void {\n    // Get primary target and listen to CDP events / 주요 타겟을 가져와서 CDP 이벤트 리스닝\n    const target = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n    if (!target) {\n      // Wait for target to be available / 타겟이 사용 가능할 때까지 대기\n      SDK.TargetManager.TargetManager.instance().addEventListener(\n        SDK.TargetManager.Events.AVAILABLE_TARGETS_CHANGED,\n        () => {\n          const newTarget = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n          if (newTarget && !this.#target) {\n            this.#target = newTarget;\n            this.attachToTarget(newTarget);\n          }\n        },\n        this\n      );\n      return;\n    }\n\n    this.#target = target;\n    this.attachToTarget(target);\n  }\n\n  private attachToTarget(target: SDK.Target.Target): void {\n    // Listen to SessionReplay.eventRecorded events / SessionReplay.eventRecorded 이벤트 리스닝\n    const router = target.router();\n    if (!router) {\n      return;\n    }\n\n    const connection = router.connection;\n    if (!connection) {\n      return;\n    }\n\n\n    // Enable SessionReplay domain / SessionReplay 도메인 활성화\n    const sessionReplayAgent = target.sessionReplayAgent();\n    if (sessionReplayAgent) {\n      sessionReplayAgent.invoke_enable().then(() => {\n\n      }).catch((_error: unknown) => {\n\n      });\n    }\n\n    this.#observer = {\n      onEvent: <T extends ProtocolClient.CDPConnection.Event>(event: ProtocolClient.CDPConnection.CDPEvent<T>): void => {\n\n\n        // Check for SessionReplay.eventRecorded event / SessionReplay.eventRecorded 이벤트 확인\n        if (event.method === 'SessionReplay.eventRecorded') {\n          const params = event.params as Protocol.SessionReplay.EventRecordedEvent;\n          if (Array.isArray(params.events)) {\n            this.#rrwebEvents.push(...params.events);\n            void this.updateReplay();\n          }\n        }\n      },\n      onDisconnect: (_reason: string): void => {\n        this.#observer = null;\n      },\n    };\n\n    connection.observe(this.#observer);\n\n  }\n\n  private render(): void {\n    // Inject rrweb-replay CSS styles / rrweb-replay CSS 스타일 주입\n    this.injectRrwebStyles();\n\n    const container = document.createElement('div');\n    container.className = 'session-replay-panel';\n\n    // Create content wrapper / 콘텐츠 래퍼 생성\n    const contentWrapper = document.createElement('div');\n    contentWrapper.className = 'session-replay-content';\n    this.#container = contentWrapper;\n    container.appendChild(contentWrapper);\n\n    // Create controls / 컨트롤 생성\n    this.createControls(container);\n\n    this.contentElement.appendChild(container);\n\n    // Update container height after layout / 레이아웃 후 컨테이너 높이 업데이트\n    this.updateContainerHeight();\n\n    void this.updateReplay();\n  }\n\n  private updateContainerHeight(): void {\n    // Calculate available height considering tab bar and controls / 탭바와 컨트롤을 고려한 사용 가능한 높이 계산\n    if (!this.#container) {\n      return;\n    }\n\n    const updateHeight = (): void => {\n      if (!this.#container) {\n        return;\n      }\n\n      // Get panel content element dimensions / 패널 콘텐츠 요소 크기 가져오기\n      const panelElement = this.contentElement;\n      const panelRect = panelElement.getBoundingClientRect();\n\n      // Get controls height if available / 컨트롤 높이 가져오기 (있는 경우)\n      const controlsHeight = this.#controlsContainer?.offsetHeight || 0;\n\n      // Calculate available height / 사용 가능한 높이 계산\n      const availableHeight = panelRect.height - controlsHeight;\n\n      // Set content wrapper height / 콘텐츠 래퍼 높이 설정\n      this.#container.style.height = `${Math.max(0, availableHeight)}px`;\n      this.#container.style.minHeight = `${Math.max(0, availableHeight)}px`;\n    };\n\n    // Update immediately / 즉시 업데이트\n    updateHeight();\n\n    // Update on resize / 리사이즈 시 업데이트\n    const resizeObserver = new ResizeObserver(() => {\n      updateHeight();\n    });\n\n    resizeObserver.observe(this.contentElement);\n\n    // Also listen to window resize / 윈도우 리사이즈도 리스닝\n    window.addEventListener('resize', updateHeight);\n  }\n\n  private createControls(container: HTMLElement): void {\n    const controlsContainer = document.createElement('div');\n    controlsContainer.className = 'session-replay-controls';\n    this.#controlsContainer = controlsContainer;\n\n    // Play/Pause button / 재생/일시정지 버튼\n    const playPauseButton = document.createElement('button');\n    playPauseButton.className = 'session-replay-play-pause';\n    playPauseButton.setAttribute('aria-label', 'Play / 재생');\n    playPauseButton.innerHTML = `\n      <svg viewBox=\"0 0 24 24\">\n        <path d=\"M8 5v14l11-7z\"/>\n      </svg>\n    `;\n    playPauseButton.addEventListener('click', () => this.togglePlayPause());\n    this.#playPauseButton = playPauseButton;\n    controlsContainer.appendChild(playPauseButton);\n\n    // Progress bar / 진행 바\n    const progressContainer = document.createElement('div');\n    progressContainer.className = 'session-replay-progress-container';\n    progressContainer.addEventListener('click', (e) => this.handleProgressClick(e));\n    const progressFill = document.createElement('div');\n    progressFill.className = 'session-replay-progress-fill';\n    progressContainer.appendChild(progressFill);\n    this.#progressBar = progressContainer;\n    this.#progressFill = progressFill;\n    controlsContainer.appendChild(progressContainer);\n\n    // Time display / 시간 표시\n    const timeDisplay = document.createElement('div');\n    timeDisplay.className = 'session-replay-time';\n    timeDisplay.textContent = '0:00 / 0:00';\n    this.#timeDisplay = timeDisplay;\n    controlsContainer.appendChild(timeDisplay);\n\n    container.appendChild(controlsContainer);\n  }\n\n  private togglePlayPause(): void {\n    if (!this.#replayer) {\n      return;\n    }\n\n    if (this.#isPlaying) {\n      // Pause playback / 재생 일시정지\n      this.#replayer.pause();\n      // Note: The pause event from emitter will update the state / 참고: emitter의 pause 이벤트가 상태를 업데이트함\n    } else {\n      // Resume or start playback / 재생 재개 또는 시작\n      // If at the end, restart from beginning / 끝에 있으면 처음부터 재시작\n      if (this.#currentTime >= this.#totalTime) {\n        this.#currentTime = 0;\n        this.updateProgress();\n      }\n      this.#replayer.play(this.#currentTime);\n      // Note: The start event from emitter will update the state / 참고: emitter의 start 이벤트가 상태를 업데이트함\n    }\n  }\n\n  private updatePlayPauseButton(isPlaying: boolean): void {\n    if (!this.#playPauseButton) {\n      return;\n    }\n\n    if (isPlaying) {\n      this.#playPauseButton.innerHTML = `\n        <svg viewBox=\"0 0 24 24\">\n          <path d=\"M6 4h4v16H6V4zm8 0h4v16h-4V4z\"/>\n        </svg>\n      `;\n      this.#playPauseButton.setAttribute('aria-label', 'Pause / 일시정지');\n    } else {\n      this.#playPauseButton.innerHTML = `\n        <svg viewBox=\"0 0 24 24\">\n          <path d=\"M8 5v14l11-7z\"/>\n        </svg>\n      `;\n      this.#playPauseButton.setAttribute('aria-label', 'Play / 재생');\n    }\n  }\n\n  private handleProgressClick(e: MouseEvent): void {\n    if (!this.#progressBar || !this.#replayer || this.#totalTime === 0) {\n      return;\n    }\n\n    const rect = this.#progressBar.getBoundingClientRect();\n    const clickX = e.clientX - rect.left;\n    const percentage = Math.max(0, Math.min(1, clickX / rect.width));\n    const targetTime = this.#totalTime * percentage;\n\n    // Update current time immediately / 현재 시간 즉시 업데이트\n    this.#currentTime = targetTime;\n    this.updateProgress();\n\n    // Seek to target time / 목표 시간으로 이동\n    if (this.#isPlaying) {\n      // If playing, pause first then play at new position / 재생 중이면 먼저 일시정지한 후 새 위치에서 재생\n      this.#replayer.pause();\n      this.#replayer.play(targetTime);\n    } else {\n      // If paused, just seek without playing / 일시정지 중이면 재생하지 않고 이동만\n      this.#replayer.pause(targetTime);\n    }\n  }\n\n  private startProgressUpdate(): void {\n    this.stopProgressUpdate();\n    this.#updateInterval = window.setInterval(() => {\n      if (this.#replayer && this.#isPlaying) {\n        // Get current time from replayer / replayer에서 현재 시간 가져오기\n        try {\n          const replayer = this.#replayer as unknown as {getCurrentTime?: () => number};\n          if (replayer.getCurrentTime) {\n            this.#currentTime = replayer.getCurrentTime();\n          } else {\n            // Fallback: estimate based on elapsed time / 대체: 경과 시간 기반 추정\n            this.#currentTime = Math.min(this.#totalTime, this.#currentTime + 100);\n          }\n        } catch (_error) {\n          // Failed to get current time / 현재 시간 가져오기 실패\n        }\n        this.updateProgress();\n      }\n    }, 100);\n  }\n\n  private stopProgressUpdate(): void {\n    if (this.#updateInterval !== null) {\n      clearInterval(this.#updateInterval);\n      this.#updateInterval = null;\n    }\n  }\n\n  private updateProgress(): void {\n    if (!this.#progressFill || !this.#timeDisplay || this.#totalTime === 0) {\n      return;\n    }\n\n    // Clamp currentTime to valid range / currentTime을 유효한 범위로 제한\n    this.#currentTime = Math.max(0, Math.min(this.#totalTime, this.#currentTime));\n\n    const percentage = Math.min(100, (this.#currentTime / this.#totalTime) * 100);\n    this.#progressFill.style.width = `${percentage}%`;\n\n    const currentTimeStr = this.formatTime(this.#currentTime);\n    const totalTimeStr = this.formatTime(this.#totalTime);\n    this.#timeDisplay.textContent = `${currentTimeStr} / ${totalTimeStr}`;\n  }\n\n  private formatTime(ms: number): string {\n    // Ensure non-negative value / 음수가 아닌 값 보장\n    const clampedMs = Math.max(0, ms);\n    const seconds = Math.floor(clampedMs / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n  }\n\n  private calculateTotalTime(): number {\n    if (this.#rrwebEvents.length === 0) {\n      return 0;\n    }\n\n    // Find the last event's timestamp / 마지막 이벤트의 타임스탬프 찾기\n    let maxTime = 0;\n    for (const event of this.#rrwebEvents) {\n      const evt = event as {timestamp?: number; delay?: number};\n      if (evt.timestamp) {\n        maxTime = Math.max(maxTime, evt.timestamp);\n      }\n    }\n\n    // Calculate relative time from first event / 첫 이벤트로부터의 상대 시간 계산\n    const firstEvent = this.#rrwebEvents[0] as {timestamp?: number};\n    if (firstEvent?.timestamp) {\n      return maxTime - firstEvent.timestamp;\n    }\n\n    return 0;\n  }\n\n  private injectRrwebStyles(): void {\n    // Check if styles are already injected / 스타일이 이미 주입되었는지 확인\n    if (document.getElementById('rrweb-replay-styles')) {\n      return;\n    }\n\n    // Inject CSS from rrweb-replay package / rrweb-replay 패키지에서 CSS 주입\n    const style = document.createElement('style');\n    style.id = 'rrweb-replay-styles';\n    style.textContent = cssStyles;\n    document.head.appendChild(style);\n  }\n\n  private async updateReplay(): Promise<void> {\n    if (!this.#container) {\n      return;\n    }\n\n    // Check if we have enough events for replay / 재생에 충분한 이벤트가 있는지 확인\n    const hasFullSnapshot = this.#rrwebEvents.some(\n      (event: unknown) => (event as {type?: number}).type === 2\n    );\n\n    if (this.#rrwebEvents.length < 2 || !hasFullSnapshot) {\n      this.#container.innerHTML = `\n        <div style=\"display: flex; align-items: center; justify-content: center; height: 100%; color: #999;\">\n          Waiting for full snapshot... (${this.#rrwebEvents.length} events)\n        </div>\n      `;\n      return;\n    }\n\n    // Initialize rrweb Replayer / rrweb Replayer 초기화\n    if (!this.#rrwebLoaded) {\n      try {\n        this.#rrwebLoaded = true;\n\n        // Clear container and create wrapper / 컨테이너 비우고 wrapper 생성\n        // Follow original rrweb pattern: wrapper has no size constraints, iframe gets fixed size / 원본 rrweb 패턴 따름: wrapper는 크기 제한 없음, iframe은 고정 크기\n        this.#container.innerHTML = '';\n        const wrapper = document.createElement('div');\n        // Wrapper uses default styles from CSS (position: relative only) / Wrapper는 CSS의 기본 스타일 사용 (position: relative만)\n        this.#container.appendChild(wrapper);\n\n        // Calculate total time / 총 시간 계산\n        this.#totalTime = this.calculateTotalTime();\n        this.#currentTime = 0;\n\n        // Get viewport size from first event / 첫 이벤트에서 뷰포트 크기 가져오기\n        let viewportWidth = 1920; // Default width / 기본 너비\n        let viewportHeight = 1080; // Default height / 기본 높이\n\n        // Try to get viewport size from Meta event / Meta 이벤트에서 뷰포트 크기 가져오기 시도\n        for (const event of this.#rrwebEvents) {\n          const evt = event as {type?: number; data?: {width?: number; height?: number}};\n          // Meta event (type 4) contains viewport size / Meta 이벤트(type 4)에 뷰포트 크기가 포함됨\n          if (evt.type === 4 && evt.data?.width && evt.data?.height) {\n            viewportWidth = evt.data.width;\n            viewportHeight = evt.data.height;\n            break;\n          }\n        }\n\n        // Create Replayer instance with collected events / 수집된 이벤트로 Replayer 인스턴스 생성\n        this.#replayer = new Replayer(this.#rrwebEvents, {\n          root: wrapper,\n          speed: 1,\n          skipInactive: false,\n          showWarning: false,\n        });\n\n        // Set fixed size for iframe after Replayer creates it / Replayer가 iframe을 생성한 후 고정 크기 설정\n        // Follow original rrweb pattern: set iframe width/height attributes / 원본 rrweb 패턴 따름: iframe width/height 속성 설정\n        setTimeout(() => {\n          if (this.#replayer) {\n            const replayer = this.#replayer as unknown as {iframe?: HTMLIFrameElement};\n            if (replayer.iframe) {\n              replayer.iframe.setAttribute('width', String(viewportWidth));\n              replayer.iframe.setAttribute('height', String(viewportHeight));\n              replayer.iframe.style.display = 'inherit';\n            }\n          }\n        }, 100);\n\n        // Setup event listeners / 이벤트 리스너 설정\n        this.setupReplayerEvents();\n\n        // Update UI / UI 업데이트\n        this.updateProgress();\n        this.updatePlayPauseButton(false);\n\n        // Don't auto-play, let user control / 자동 재생하지 않고 사용자가 제어하도록\n        // this.#replayer.play();\n      } catch (error) {\n        this.#container.innerHTML = `\n          <div style=\"display: flex; align-items: center; justify-content: center; height: 100%; color: #f00;\">\n            Failed to load replay: ${error instanceof Error ? error.message : String(error)}\n          </div>\n        `;\n        this.#rrwebLoaded = false;\n      }\n    } else if (this.#replayer) {\n      // If new events arrive, we need to recreate the replayer / 새 이벤트가 도착하면 replayer를 재생성해야 함\n      // rrweb Replayer doesn't support updating events after initialization\n      // rrweb Replayer는 초기화 후 이벤트 업데이트를 지원하지 않음\n      this.stopProgressUpdate();\n      this.#replayer.pause();\n      this.#replayer = null;\n      this.#rrwebLoaded = false;\n      await this.updateReplay();\n    }\n  }\n\n  private setupReplayerEvents(): void {\n    if (!this.#replayer) {\n      return;\n    }\n\n    // Listen to replayer events if available / 가능한 경우 replayer 이벤트 리스닝\n    try {\n      // Try to access emitter if available / 가능한 경우 emitter에 접근 시도\n      const replayer = this.#replayer as unknown as {\n        emitter?: {\n          on?: (event: string, callback: () => void) => void;\n        };\n        getCurrentTime?: () => number;\n      };\n\n      if (replayer.emitter?.on) {\n        // Listen to start event / start 이벤트 리스닝\n        replayer.emitter.on('start', () => {\n          this.#isPlaying = true;\n          this.updatePlayPauseButton(true);\n          this.startProgressUpdate();\n        });\n\n        // Listen to pause event / pause 이벤트 리스닝\n        replayer.emitter.on('pause', () => {\n          this.#isPlaying = false;\n          this.updatePlayPauseButton(false);\n          this.stopProgressUpdate();\n          // Update current time when paused / 일시정지 시 현재 시간 업데이트\n          if (replayer.getCurrentTime) {\n            this.#currentTime = replayer.getCurrentTime();\n            this.updateProgress();\n          }\n        });\n\n        // Listen to finish event / finish 이벤트 리스닝\n        replayer.emitter.on('finish', () => {\n          this.#isPlaying = false;\n          this.#currentTime = this.#totalTime;\n          this.updatePlayPauseButton(false);\n          this.stopProgressUpdate();\n          this.updateProgress();\n        });\n      }\n    } catch (_error) {\n      // Could not setup replayer events / replayer 이벤트 설정 실패\n    }\n  }\n\n  override willHide(): void {\n    super.willHide();\n    // Notify parent/opener window that SessionReplay panel is being hidden / 부모/opener 창에 SessionReplay 패널이 숨겨지고 있음을 알림\n    // This allows Inspector to stop sending events and buffer them instead / 이를 통해 Inspector가 이벤트 전송을 중지하고 버퍼링할 수 있음\n    if (window !== window.top) {\n      // Iframe mode: send to parent / Iframe 모드: parent에 전송\n      window.parent.postMessage({ type: 'SESSION_REPLAY_HIDDEN' }, '*');\n    } else if (window.opener) {\n      // Popup/WebSocket mode: send to opener / Popup/웹소켓 모드: opener에 전송\n      window.opener.postMessage({ type: 'SESSION_REPLAY_HIDDEN' }, '*');\n    }\n\n    // Clean up when panel is hidden / 패널이 숨겨질 때 정리\n    this.stopProgressUpdate();\n    if (this.#replayer) {\n      this.#replayer.pause();\n      this.#isPlaying = false;\n    }\n  }\n\n  static instance(opts: {forceNew: boolean|null} = {forceNew: null}): SessionReplayPanel {\n    const {forceNew} = opts;\n    if (!sessionReplayPanelInstance || forceNew) {\n      sessionReplayPanelInstance = new SessionReplayPanel();\n    }\n    return sessionReplayPanelInstance;\n  }\n}\n\n"],
  "mappings": "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",
  "names": []
}

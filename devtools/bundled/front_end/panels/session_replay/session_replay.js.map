{
  "version": 3,
  "sources": ["../../../../../../front_end/panels/session_replay/SessionReplayPanel.ts"],
  "sourcesContent": ["// Copyright 2025 The Chromium Authors\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as UI from '../../ui/legacy/legacy.js';\nimport * as SDK from '../../core/sdk/sdk.js';\nimport * as ProtocolClient from '../../core/protocol_client/protocol_client.js';\nimport type * as Protocol from '../../generated/protocol.js';\nimport { Replayer, type ReplayerClass, cssStyles } from '../../third_party/rrweb-replay/rrweb-replay.js';\n\nlet sessionReplayPanelInstance: SessionReplayPanel;\n\nexport class SessionReplayPanel extends UI.Panel.Panel {\n  #rrwebEvents: unknown[] = [];\n  #container: HTMLElement|null = null;\n  #target: SDK.Target.Target|null = null;\n  #observer: ProtocolClient.CDPConnection.CDPConnectionObserver|null = null;\n  #replayer: InstanceType<ReplayerClass>|null = null; // Replayer instance / Replayer 인스턴스\n  #rrwebLoaded = false; // Flag to track if rrweb is loaded / rrweb 로드 여부 플래그\n  #controlsContainer: HTMLElement|null = null; // Controls container / 컨트롤 컨테이너 (for future use / 향후 사용)\n  #playPauseButton: HTMLElement|null = null; // Play/pause button / 재생/일시정지 버튼\n  #progressBar: HTMLElement|null = null; // Progress bar / 진행 바\n  #progressFill: HTMLElement|null = null; // Progress fill / 진행 채우기\n  #timeDisplay: HTMLElement|null = null; // Time display / 시간 표시\n  #isPlaying = false; // Playing state / 재생 상태\n  #currentTime = 0; // Current time in ms / 현재 시간 (ms)\n  #totalTime = 0; // Total time in ms / 총 시간 (ms)\n  #updateInterval: number|null = null; // Update interval ID / 업데이트 간격 ID\n\n  constructor() {\n    super('session-replay');\n    console.log('SessionReplay: Panel constructor called / 패널 생성자 호출됨');\n    this.render();\n  }\n\n  override wasShown(): void {\n    super.wasShown();\n    console.log('SessionReplay: Panel was shown / 패널 표시됨');\n\n    // Update container height when panel is shown / 패널이 표시될 때 컨테이너 높이 업데이트\n    this.updateContainerHeight();\n\n    // Setup CDP listener when panel is shown / 패널이 표시될 때 CDP 리스너 설정\n    this.setupCDPListener();\n\n    // Also try to setup listener after a short delay in case target becomes available / 타겟이 나중에 사용 가능해질 수 있으므로 짧은 지연 후에도 시도\n    setTimeout(() => {\n      if (!this.#target) {\n        console.log('SessionReplay: Retrying setup after delay / 지연 후 재시도');\n        this.setupCDPListener();\n      }\n      // Update height again after delay to ensure correct calculation / 지연 후 높이를 다시 업데이트하여 정확한 계산 보장\n      this.updateContainerHeight();\n    }, 1000);\n  }\n\n  private setupCDPListener(): void {\n    console.log('SessionReplay: setupCDPListener called / setupCDPListener 호출됨');\n    // Get primary target and listen to CDP events / 주요 타겟을 가져와서 CDP 이벤트 리스닝\n    const target = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n    console.log('SessionReplay: Primary target / 주요 타겟:', target);\n    if (!target) {\n      console.log('SessionReplay: No target available, waiting... / 타겟 없음, 대기 중...');\n      // Wait for target to be available / 타겟이 사용 가능할 때까지 대기\n      SDK.TargetManager.TargetManager.instance().addEventListener(\n        SDK.TargetManager.Events.AVAILABLE_TARGETS_CHANGED,\n        () => {\n          console.log('SessionReplay: AVAILABLE_TARGETS_CHANGED event / 타겟 변경 이벤트');\n          const newTarget = SDK.TargetManager.TargetManager.instance().primaryPageTarget();\n          if (newTarget && !this.#target) {\n            console.log('SessionReplay: New target available / 새 타겟 사용 가능:', newTarget);\n            this.#target = newTarget;\n            this.attachToTarget(newTarget);\n          }\n        },\n        this\n      );\n      return;\n    }\n\n    console.log('SessionReplay: Target available, attaching... / 타겟 사용 가능, 연결 중...');\n    this.#target = target;\n    this.attachToTarget(target);\n  }\n\n  private attachToTarget(target: SDK.Target.Target): void {\n    // Listen to SessionReplay.eventRecorded events / SessionReplay.eventRecorded 이벤트 리스닝\n    const router = target.router();\n    if (!router) {\n      console.warn('SessionReplay: Router not available / 라우터를 사용할 수 없음');\n      return;\n    }\n\n    const connection = router.connection;\n    if (!connection) {\n      console.warn('SessionReplay: Connection not available / 연결을 사용할 수 없음');\n      return;\n    }\n\n    console.log('SessionReplay: Attaching to target / 타겟에 연결 중...', target);\n\n    // Enable SessionReplay domain / SessionReplay 도메인 활성화\n    const sessionReplayAgent = target.sessionReplayAgent();\n    if (sessionReplayAgent) {\n      sessionReplayAgent.invoke_enable().then(() => {\n        console.log('SessionReplay: Domain enabled / 도메인 활성화됨');\n      }).catch((error: unknown) => {\n        console.error('SessionReplay: Failed to enable domain / 도메인 활성화 실패:', error);\n      });\n    } else {\n      console.warn('SessionReplay: SessionReplayAgent not available / SessionReplayAgent를 사용할 수 없음');\n    }\n\n    this.#observer = {\n      onEvent: <T extends ProtocolClient.CDPConnection.Event>(event: ProtocolClient.CDPConnection.CDPEvent<T>): void => {\n        // Log first few events for debugging / 디버깅을 위해 처음 몇 개 이벤트 로깅\n        if (this.#rrwebEvents.length < 5) {\n          console.log('SessionReplay: CDP event received / CDP 이벤트 수신:', event.method, event.params);\n        }\n\n        // Log all SessionReplay related events for debugging / 디버깅을 위해 모든 SessionReplay 관련 이벤트 로깅\n        if (event.method?.includes('SessionReplay') || event.method?.toLowerCase().includes('session')) {\n          console.log('SessionReplay: Received SessionReplay event / SessionReplay 이벤트 수신:', event.method, event.params);\n        }\n\n        // Check for SessionReplay.eventRecorded event / SessionReplay.eventRecorded 이벤트 확인\n        if (event.method === 'SessionReplay.eventRecorded') {\n          const params = event.params as Protocol.SessionReplay.EventRecordedEvent;\n          console.log('SessionReplay: eventRecorded event received / eventRecorded 이벤트 수신:', params);\n          if (Array.isArray(params.events)) {\n            console.log('SessionReplay: Received events / 이벤트 수신:', params.events.length);\n            this.#rrwebEvents.push(...params.events);\n            console.log('SessionReplay: Total events / 총 이벤트:', this.#rrwebEvents.length);\n            void this.updateReplay();\n          } else {\n            console.warn('SessionReplay: params.events is not an array / params.events가 배열이 아님:', params);\n          }\n        }\n      },\n      onDisconnect: (_reason: string): void => {\n        console.log('SessionReplay: Connection disconnected / 연결 끊김:', _reason);\n        this.#observer = null;\n      },\n    };\n\n    connection.observe(this.#observer);\n    console.log('SessionReplay: Observer attached / 옵저버 연결됨');\n    console.log('SessionReplay: Connection state / 연결 상태:', {\n      hasObserver: !!this.#observer,\n      connectionReady: !!connection,\n      targetId: target.id(),\n    });\n  }\n\n  private render(): void {\n    // Inject rrweb-replay CSS styles / rrweb-replay CSS 스타일 주입\n    this.injectRrwebStyles();\n\n    const container = document.createElement('div');\n    container.className = 'session-replay-panel';\n\n    // Create content wrapper / 콘텐츠 래퍼 생성\n    const contentWrapper = document.createElement('div');\n    contentWrapper.className = 'session-replay-content';\n    this.#container = contentWrapper;\n    container.appendChild(contentWrapper);\n\n    // Create controls / 컨트롤 생성\n    this.createControls(container);\n\n    this.contentElement.appendChild(container);\n\n    // Update container height after layout / 레이아웃 후 컨테이너 높이 업데이트\n    this.updateContainerHeight();\n\n    void this.updateReplay();\n  }\n\n  private updateContainerHeight(): void {\n    // Calculate available height considering tab bar and controls / 탭바와 컨트롤을 고려한 사용 가능한 높이 계산\n    if (!this.#container) {\n      return;\n    }\n\n    const updateHeight = (): void => {\n      if (!this.#container) {\n        return;\n      }\n\n      // Get panel content element dimensions / 패널 콘텐츠 요소 크기 가져오기\n      const panelElement = this.contentElement;\n      const panelRect = panelElement.getBoundingClientRect();\n\n      // Get controls height if available / 컨트롤 높이 가져오기 (있는 경우)\n      const controlsHeight = this.#controlsContainer?.offsetHeight || 0;\n\n      // Calculate available height / 사용 가능한 높이 계산\n      const availableHeight = panelRect.height - controlsHeight;\n\n      // Set content wrapper height / 콘텐츠 래퍼 높이 설정\n      this.#container.style.height = `${Math.max(0, availableHeight)}px`;\n      this.#container.style.minHeight = `${Math.max(0, availableHeight)}px`;\n    };\n\n    // Update immediately / 즉시 업데이트\n    updateHeight();\n\n    // Update on resize / 리사이즈 시 업데이트\n    const resizeObserver = new ResizeObserver(() => {\n      updateHeight();\n    });\n\n    resizeObserver.observe(this.contentElement);\n\n    // Also listen to window resize / 윈도우 리사이즈도 리스닝\n    window.addEventListener('resize', updateHeight);\n  }\n\n  private createControls(container: HTMLElement): void {\n    const controlsContainer = document.createElement('div');\n    controlsContainer.className = 'session-replay-controls';\n    this.#controlsContainer = controlsContainer;\n\n    // Play/Pause button / 재생/일시정지 버튼\n    const playPauseButton = document.createElement('button');\n    playPauseButton.className = 'session-replay-play-pause';\n    playPauseButton.setAttribute('aria-label', 'Play / 재생');\n    playPauseButton.innerHTML = `\n      <svg viewBox=\"0 0 24 24\">\n        <path d=\"M8 5v14l11-7z\"/>\n      </svg>\n    `;\n    playPauseButton.addEventListener('click', () => this.togglePlayPause());\n    this.#playPauseButton = playPauseButton;\n    controlsContainer.appendChild(playPauseButton);\n\n    // Progress bar / 진행 바\n    const progressContainer = document.createElement('div');\n    progressContainer.className = 'session-replay-progress-container';\n    progressContainer.addEventListener('click', (e) => this.handleProgressClick(e));\n    const progressFill = document.createElement('div');\n    progressFill.className = 'session-replay-progress-fill';\n    progressContainer.appendChild(progressFill);\n    this.#progressBar = progressContainer;\n    this.#progressFill = progressFill;\n    controlsContainer.appendChild(progressContainer);\n\n    // Time display / 시간 표시\n    const timeDisplay = document.createElement('div');\n    timeDisplay.className = 'session-replay-time';\n    timeDisplay.textContent = '0:00 / 0:00';\n    this.#timeDisplay = timeDisplay;\n    controlsContainer.appendChild(timeDisplay);\n\n    container.appendChild(controlsContainer);\n  }\n\n  private togglePlayPause(): void {\n    if (!this.#replayer) {\n      return;\n    }\n\n    if (this.#isPlaying) {\n      // Pause playback / 재생 일시정지\n      this.#replayer.pause();\n      // Note: The pause event from emitter will update the state / 참고: emitter의 pause 이벤트가 상태를 업데이트함\n    } else {\n      // Resume or start playback / 재생 재개 또는 시작\n      // If at the end, restart from beginning / 끝에 있으면 처음부터 재시작\n      if (this.#currentTime >= this.#totalTime) {\n        this.#currentTime = 0;\n        this.updateProgress();\n      }\n      this.#replayer.play(this.#currentTime);\n      // Note: The start event from emitter will update the state / 참고: emitter의 start 이벤트가 상태를 업데이트함\n    }\n  }\n\n  private updatePlayPauseButton(isPlaying: boolean): void {\n    if (!this.#playPauseButton) {\n      return;\n    }\n\n    if (isPlaying) {\n      this.#playPauseButton.innerHTML = `\n        <svg viewBox=\"0 0 24 24\">\n          <path d=\"M6 4h4v16H6V4zm8 0h4v16h-4V4z\"/>\n        </svg>\n      `;\n      this.#playPauseButton.setAttribute('aria-label', 'Pause / 일시정지');\n    } else {\n      this.#playPauseButton.innerHTML = `\n        <svg viewBox=\"0 0 24 24\">\n          <path d=\"M8 5v14l11-7z\"/>\n        </svg>\n      `;\n      this.#playPauseButton.setAttribute('aria-label', 'Play / 재생');\n    }\n  }\n\n  private handleProgressClick(e: MouseEvent): void {\n    if (!this.#progressBar || !this.#replayer || this.#totalTime === 0) {\n      return;\n    }\n\n    const rect = this.#progressBar.getBoundingClientRect();\n    const clickX = e.clientX - rect.left;\n    const percentage = Math.max(0, Math.min(1, clickX / rect.width));\n    const targetTime = this.#totalTime * percentage;\n\n    // Update current time immediately / 현재 시간 즉시 업데이트\n    this.#currentTime = targetTime;\n    this.updateProgress();\n\n    // Seek to target time / 목표 시간으로 이동\n    if (this.#isPlaying) {\n      // If playing, pause first then play at new position / 재생 중이면 먼저 일시정지한 후 새 위치에서 재생\n      this.#replayer.pause();\n      this.#replayer.play(targetTime);\n    } else {\n      // If paused, just seek without playing / 일시정지 중이면 재생하지 않고 이동만\n      this.#replayer.pause(targetTime);\n    }\n  }\n\n  private startProgressUpdate(): void {\n    this.stopProgressUpdate();\n    this.#updateInterval = window.setInterval(() => {\n      if (this.#replayer && this.#isPlaying) {\n        // Get current time from replayer / replayer에서 현재 시간 가져오기\n        try {\n          const replayer = this.#replayer as unknown as {getCurrentTime?: () => number};\n          if (replayer.getCurrentTime) {\n            this.#currentTime = replayer.getCurrentTime();\n          } else {\n            // Fallback: estimate based on elapsed time / 대체: 경과 시간 기반 추정\n            this.#currentTime = Math.min(this.#totalTime, this.#currentTime + 100);\n          }\n        } catch (error) {\n          console.warn('SessionReplay: Failed to get current time / 현재 시간 가져오기 실패:', error);\n        }\n        this.updateProgress();\n      }\n    }, 100);\n  }\n\n  private stopProgressUpdate(): void {\n    if (this.#updateInterval !== null) {\n      clearInterval(this.#updateInterval);\n      this.#updateInterval = null;\n    }\n  }\n\n  private updateProgress(): void {\n    if (!this.#progressFill || !this.#timeDisplay || this.#totalTime === 0) {\n      return;\n    }\n\n    const percentage = Math.min(100, (this.#currentTime / this.#totalTime) * 100);\n    this.#progressFill.style.width = `${percentage}%`;\n\n    const currentTimeStr = this.formatTime(this.#currentTime);\n    const totalTimeStr = this.formatTime(this.#totalTime);\n    this.#timeDisplay.textContent = `${currentTimeStr} / ${totalTimeStr}`;\n  }\n\n  private formatTime(ms: number): string {\n    const seconds = Math.floor(ms / 1000);\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;\n  }\n\n  private calculateTotalTime(): number {\n    if (this.#rrwebEvents.length === 0) {\n      return 0;\n    }\n\n    // Find the last event's timestamp / 마지막 이벤트의 타임스탬프 찾기\n    let maxTime = 0;\n    for (const event of this.#rrwebEvents) {\n      const evt = event as {timestamp?: number; delay?: number};\n      if (evt.timestamp) {\n        maxTime = Math.max(maxTime, evt.timestamp);\n      }\n    }\n\n    // Calculate relative time from first event / 첫 이벤트로부터의 상대 시간 계산\n    const firstEvent = this.#rrwebEvents[0] as {timestamp?: number};\n    if (firstEvent?.timestamp) {\n      return maxTime - firstEvent.timestamp;\n    }\n\n    return 0;\n  }\n\n  private injectRrwebStyles(): void {\n    // Check if styles are already injected / 스타일이 이미 주입되었는지 확인\n    if (document.getElementById('rrweb-replay-styles')) {\n      return;\n    }\n\n    // Inject CSS from rrweb-replay package / rrweb-replay 패키지에서 CSS 주입\n    const style = document.createElement('style');\n    style.id = 'rrweb-replay-styles';\n    style.textContent = cssStyles;\n    document.head.appendChild(style);\n  }\n\n  private async updateReplay(): Promise<void> {\n    if (!this.#container) {\n      console.warn('SessionReplay: Container not available / 컨테이너를 사용할 수 없음');\n      return;\n    }\n\n    // Check if we have enough events for replay / 재생에 충분한 이벤트가 있는지 확인\n    const hasFullSnapshot = this.#rrwebEvents.some(\n      (event: unknown) => (event as {type?: number}).type === 2\n    );\n\n    console.log('SessionReplay: updateReplay called / updateReplay 호출됨', {\n      eventCount: this.#rrwebEvents.length,\n      hasFullSnapshot,\n      rrwebLoaded: this.#rrwebLoaded,\n    });\n\n    if (this.#rrwebEvents.length < 2 || !hasFullSnapshot) {\n      this.#container.innerHTML = `\n        <div style=\"display: flex; align-items: center; justify-content: center; height: 100%; color: #999;\">\n          Waiting for full snapshot... (${this.#rrwebEvents.length} events)\n        </div>\n      `;\n      return;\n    }\n\n    // Initialize rrweb Replayer / rrweb Replayer 초기화\n    if (!this.#rrwebLoaded) {\n      try {\n        console.log('SessionReplay: Initializing Replayer / Replayer 초기화 중...');\n        console.log('SessionReplay: Replayer class / Replayer 클래스:', Replayer);\n\n        this.#rrwebLoaded = true;\n\n        // Clear container and create wrapper / 컨테이너 비우고 wrapper 생성\n        // Follow original rrweb pattern: wrapper has no size constraints, iframe gets fixed size / 원본 rrweb 패턴 따름: wrapper는 크기 제한 없음, iframe은 고정 크기\n        this.#container.innerHTML = '';\n        const wrapper = document.createElement('div');\n        // Wrapper uses default styles from CSS (position: relative only) / Wrapper는 CSS의 기본 스타일 사용 (position: relative만)\n        this.#container.appendChild(wrapper);\n\n        console.log('SessionReplay: Creating Replayer with events / 이벤트로 Replayer 생성:', this.#rrwebEvents.length);\n\n        // Calculate total time / 총 시간 계산\n        this.#totalTime = this.calculateTotalTime();\n        this.#currentTime = 0;\n\n        // Get viewport size from first event / 첫 이벤트에서 뷰포트 크기 가져오기\n        let viewportWidth = 1920; // Default width / 기본 너비\n        let viewportHeight = 1080; // Default height / 기본 높이\n\n        // Try to get viewport size from Meta event / Meta 이벤트에서 뷰포트 크기 가져오기 시도\n        for (const event of this.#rrwebEvents) {\n          const evt = event as {type?: number; data?: {width?: number; height?: number}};\n          // Meta event (type 4) contains viewport size / Meta 이벤트(type 4)에 뷰포트 크기가 포함됨\n          if (evt.type === 4 && evt.data?.width && evt.data?.height) {\n            viewportWidth = evt.data.width;\n            viewportHeight = evt.data.height;\n            console.log('SessionReplay: Found viewport size from Meta event / Meta 이벤트에서 뷰포트 크기 발견:', {\n              width: viewportWidth,\n              height: viewportHeight,\n            });\n            break;\n          }\n        }\n\n        // Create Replayer instance with collected events / 수집된 이벤트로 Replayer 인스턴스 생성\n        this.#replayer = new Replayer(this.#rrwebEvents, {\n          root: wrapper,\n          speed: 1,\n          skipInactive: false,\n          showWarning: false,\n        });\n\n        console.log('SessionReplay: Replayer created / Replayer 생성됨', {\n          totalTime: this.#totalTime,\n          eventCount: this.#rrwebEvents.length,\n        });\n\n        // Set fixed size for iframe after Replayer creates it / Replayer가 iframe을 생성한 후 고정 크기 설정\n        // Follow original rrweb pattern: set iframe width/height attributes / 원본 rrweb 패턴 따름: iframe width/height 속성 설정\n        setTimeout(() => {\n          if (this.#replayer) {\n            const replayer = this.#replayer as unknown as {iframe?: HTMLIFrameElement};\n            if (replayer.iframe) {\n              replayer.iframe.setAttribute('width', String(viewportWidth));\n              replayer.iframe.setAttribute('height', String(viewportHeight));\n              replayer.iframe.style.display = 'inherit';\n              console.log('SessionReplay: Set iframe size / iframe 크기 설정:', {\n                width: viewportWidth,\n                height: viewportHeight,\n              });\n            }\n          }\n        }, 100);\n\n        // Setup event listeners / 이벤트 리스너 설정\n        this.setupReplayerEvents();\n\n        // Update UI / UI 업데이트\n        this.updateProgress();\n        this.updatePlayPauseButton(false);\n\n        // Don't auto-play, let user control / 자동 재생하지 않고 사용자가 제어하도록\n        // this.#replayer.play();\n      } catch (error) {\n        console.error('Failed to initialize rrweb replayer / rrweb replayer 초기화 실패:', error);\n        console.error('Error details / 오류 상세:', {\n          error,\n          errorMessage: error instanceof Error ? error.message : String(error),\n          errorStack: error instanceof Error ? error.stack : undefined,\n          ReplayerAvailable: typeof Replayer !== 'undefined',\n        });\n        this.#container.innerHTML = `\n          <div style=\"display: flex; align-items: center; justify-content: center; height: 100%; color: #f00;\">\n            Failed to load replay: ${error instanceof Error ? error.message : String(error)}\n          </div>\n        `;\n        this.#rrwebLoaded = false;\n      }\n    } else if (this.#replayer) {\n      // If new events arrive, we need to recreate the replayer / 새 이벤트가 도착하면 replayer를 재생성해야 함\n      // rrweb Replayer doesn't support updating events after initialization\n      // rrweb Replayer는 초기화 후 이벤트 업데이트를 지원하지 않음\n      console.log('SessionReplay: Recreating replayer with new events / 새 이벤트로 replayer 재생성');\n      this.stopProgressUpdate();\n      this.#replayer.pause();\n      this.#replayer = null;\n      this.#rrwebLoaded = false;\n      await this.updateReplay();\n    }\n  }\n\n  private setupReplayerEvents(): void {\n    if (!this.#replayer) {\n      return;\n    }\n\n    // Listen to replayer events if available / 가능한 경우 replayer 이벤트 리스닝\n    try {\n      // Try to access emitter if available / 가능한 경우 emitter에 접근 시도\n      const replayer = this.#replayer as unknown as {\n        emitter?: {\n          on?: (event: string, callback: () => void) => void;\n        };\n        getCurrentTime?: () => number;\n      };\n\n      if (replayer.emitter?.on) {\n        // Listen to start event / start 이벤트 리스닝\n        replayer.emitter.on('start', () => {\n          console.log('SessionReplay: Replayer started / Replayer 시작됨');\n          this.#isPlaying = true;\n          this.updatePlayPauseButton(true);\n          this.startProgressUpdate();\n        });\n\n        // Listen to pause event / pause 이벤트 리스닝\n        replayer.emitter.on('pause', () => {\n          console.log('SessionReplay: Replayer paused / Replayer 일시정지됨');\n          this.#isPlaying = false;\n          this.updatePlayPauseButton(false);\n          this.stopProgressUpdate();\n          // Update current time when paused / 일시정지 시 현재 시간 업데이트\n          if (replayer.getCurrentTime) {\n            this.#currentTime = replayer.getCurrentTime();\n            this.updateProgress();\n          }\n        });\n\n        // Listen to finish event / finish 이벤트 리스닝\n        replayer.emitter.on('finish', () => {\n          console.log('SessionReplay: Replayer finished / Replayer 종료됨');\n          this.#isPlaying = false;\n          this.#currentTime = this.#totalTime;\n          this.updatePlayPauseButton(false);\n          this.stopProgressUpdate();\n          this.updateProgress();\n        });\n      } else {\n        console.warn('SessionReplay: Emitter not available / Emitter를 사용할 수 없음');\n      }\n    } catch (error) {\n      console.warn('SessionReplay: Could not setup replayer events / replayer 이벤트 설정 실패:', error);\n    }\n  }\n\n  override willHide(): void {\n    super.willHide();\n    // Clean up when panel is hidden / 패널이 숨겨질 때 정리\n    this.stopProgressUpdate();\n    if (this.#replayer) {\n      this.#replayer.pause();\n      this.#isPlaying = false;\n    }\n  }\n\n  static instance(opts: {forceNew: boolean|null} = {forceNew: null}): SessionReplayPanel {\n    const {forceNew} = opts;\n    if (!sessionReplayPanelInstance || forceNew) {\n      sessionReplayPanelInstance = new SessionReplayPanel();\n    }\n    return sessionReplayPanelInstance;\n  }\n}\n\n"],
  "mappings": "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",
  "names": []
}
